% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step-VPD-ECC.R
\name{step_vpd_ecc}
\alias{step_vpd_ecc}
\title{Vectorize persistence data as Euler characteristic curves}
\usage{
step_vpd_ecc(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  dim_max = Inf,
  scale_seq = NULL,
  columns = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("vpd_ecc")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{...}{One or more selector functions to choose which variables are
affected by the step.}

\item{role}{For model terms created by this step, what analysis role should
they be assigned? By default, the function assumes that the new columns
created by the original variables will be used as predictors in a model.}

\item{trained}{A logical value indicating whether the values used for
binarization have been checked.}

\item{dim_max, scale_seq}{Parameters used by {TDAvec}.}

\item{columns}{A character string of the selected variable names. This field
is a placeholder and will be populated once \code{\link[recipes:prep]{prep()}} is used.}

\item{keep_original_cols}{A logical to keep the original variables in the
output. Defaults to \code{FALSE}.}

\item{skip}{A logical value indicating whether the step should be skipped
when the recipe is baked by \code{bake.recipe()}.}

\item{id}{A character string that is unique to this step, used to identify
it.}
}
\value{
An updated version of \code{recipe} with the new step added to the
sequence of existing steps (if any).
}
\description{
The functions \verb{step_vpd_*()} create \emph{specifications} of recipe
steps that will convert 3-column matrix representations of persistence
diagrams to 1-row matrices of vectorizations.
}
\details{
(What are ECCs?)

(Guidelines / good practice?)

(Describe arguments in detail.)
}
\examples{
# toy data set
klein_sampler <- function(n, prob = .5) {
  if (rbinom(1, 1, prob) == 0) {
    tdaunif::sample_klein_flat(n)
  } else {
    tdaunif::sample_klein_tube(n)
  }
}
phom_data <- data.frame(
  id = LETTERS[seq(6L)],
  phom = I(lapply(
    replicate(6L, klein_sampler(60), simplify = FALSE),
    \(d) as.data.frame(ripserr::vietoris_rips(d))
  )),
  part = rep(c("train", "test"), each = 3)
)
print(phom_data)
head(phom_data$phom[[1]])

phom_train <- filter(phom_data, part == "train")
phom_test <- filter(phom_data, part == "test")

# guess maximum filtration parameter
phom_train$phom |> 
  lapply(\(d) d$death) |> 
  unlist() |> max() |> 
  print() -> max_threshold
# create grid
phom_seq <- seq(0, round(max_threshold * 2.01, digits = 2), .01)

# build preprocessing recipe with custom settings
phom_train \%>\%
  recipe() \%>\%
  update_role(id, new_role = "id") \%>\%
  step_vpd_ecc(phom, dim_max = 2, scale_seq = phom_seq) \%>\%
  prep(training = phom_train, strings_as_factors = FALSE) ->
  phom_rec
print(phom_rec)

# build preprocessing recipe with default settings
phom_train \%>\%
  recipe() \%>\%
  update_role(id, new_role = "id") \%>\%
  step_vpd_ecc(phom) \%>\%
  prep(training = phom_train, strings_as_factors = FALSE) ->
  phom_rec
print(phom_rec)

# preprocess training data
juice(phom_rec)

# preprocess testing data
bake(phom_test, object = phom_rec)

# two-step recipe from sample to vectorization
sample_data <- data.frame(
  id = LETTERS[seq(6L)],
  sample = I(c(replicate(6L, klein_sampler(60), simplify = FALSE))),
  part = rep(c("train", "test"), each = 3L)
)
sample_train <- filter(sample_data, part == "train")
sample_test <- filter(sample_data, part == "test")

# build preprocessing recipe with default settings
sample_train \%>\%
  recipe() \%>\%
  update_role(id, new_role = "id") \%>\%
  step_phom(sample, engine = "ripserr") \%>\%
  step_vpd_ecc(sample_phom) \%>\%
  prep(training = sample_train, strings_as_factors = FALSE) ->
  sample_rec
print(sample_rec)

# preprocess training data
juice(sample_rec)

# preprocess testing data
bake(sample_test, object = sample_rec)
}
