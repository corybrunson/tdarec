#' This script assembles source files containing objects, methods, and
#' {roxygen2} documentation for {recipe} steps to perform vectorizations of
#' persistent homology provided by {TDAvec}.
#'
#' To generate or update these files, execute the following:
#' source(here::here("build-pre/build-tdavec-steps.R"))
#' 
#' Refer to the following resources for guidance:
#' https://blog.r-hub.io/2020/02/10/code-generation/
#' https://www.tidymodels.org/learn/develop/recipes/

#' SETUP

#' Set build parameters.

# standard prefix for built files
build_prefix <- "zzz"

# warning not to edit by hand
build_warning <- glue::glue(
  "# --------------------------------------",
  "----------------------------------------\n",
  "# Generated by 'build-pre/build-tdavec-steps.R': do not edit by hand.\n",
  "# --------------------------------------",
  "----------------------------------------\n\n\n",
)

# source building utilities
source(here::here("build-pre/build-tdavec.R"))

#' GENERATORS

#' Generate step documentation.

# format custom parameters for inclusion into step arguments and augment scale
# sequence parameters with scale sequence-generating parameters on one line
custom_params_leave <- function(args) {
  params <- unname(arg_params[args])
  lines <- params
  lines <- gsub(
    "([xy]{1})seq",
    paste0(
      vapply(c("seq", "min", "max", "len", "by"), \(s) paste0("\\1", s), ""),
      collapse = ", "
    ),
    lines
  )
  lines
}
custom_params_set <- function(args) {
  params <- unname(arg_params[args])
  lines <- paste0(params, " = ", param_defaults[params])
  # if no default provided, use `NULL`
  lines <- gsub(" NA$", " NULL", lines)
  lines <- gsub(
    "([xy]{1})seq = NULL",
    paste0(
      c("\\1seq", "\\1min", "\\1max", "\\1len", "\\1by"),
      " = NULL", collapse = ", "
    ),
    lines
  )
  lines
}
custom_params_pass <- function(args) {
  params <- unname(arg_params[args])
  lines <- paste0(params, " = ", params)
  lines <- gsub(
    "([xy]{1})seq = \\1seq",
    paste0(
      vapply(
        c("seq", "min", "max", "len", "by"),
        \(s) paste0("\\1", s, " = \\1", s),
        ""
      ),
      collapse = ", "
    ),
    lines
  )
  lines
}
custom_params_elt <- function(args) {
  lines <- custom_params_pass(args)
  lines <- gsub(" = ", " = x\\$", lines)
  lines
}
custom_params_compute <- function(args) {
  params <- unname(arg_params[args])
  lines <- paste0(args, " = object$", params)
  lines
}
# custom_params_leave(c("homDim", "scaleSeq", "tau"))
# custom_params_set(c("homDim", "scaleSeq", "tau"))
# custom_params_pass(c("homDim", "scaleSeq", "tau"))
# custom_params_elt(c("homDim", "scaleSeq", "tau"))
# custom_params_compute(c("homDim", "scaleSeq", "tau"))

# preprocessing code for each parameter
param_preprocesses <- list(
  # no pre-processing for homological degree (defalts to `0L`)
  hom_degree = c(),
  # if maximum degree is not specified, use the maximum data dimension
  max_hom_degree = c(
    "if (x$max_hom_degree == Inf)",
    "  x$max_hom_degree <- get_max_hom_degree(training[, col_names, drop = FALSE])"
  ),
  # reconcile scale sequence parameters
  xseq = c(
    "x[paste0(\"x\", c(\"seq\", \"min\", \"max\", \"len\", \"by\"))] <- ",
    "  reconcile_scale_seq(x, training[, col_names, drop = FALSE], \"x\")"
  ),
  yseq = c(
    "x[paste0(\"y\", c(\"seq\", \"min\", \"max\", \"len\", \"by\"))] <- ",
    "  reconcile_scale_seq(x, training[, col_names, drop = FALSE], \"y\")"
  ),
  # TODO: pre-process `num_levels`
  num_levels = c(),
  # TODO: pre-process `dist_power`
  dist_power = c(),
  # TODO: pre-process `img_sigma`
  img_sigma = c(),
  # TODO: pre-process `block_size`
  block_size = c()
)

# generate title and description
build_title_descr <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_title <- tdavec_content |> 
    filter(name == fn) |> 
    pull(step_title) |> first()
  fn_title_doc <- paste0("@title ", fn_title)
  fn_descr <- c(
    paste0("@description The function `step_vpd_", fn_abbr, "()` creates"),
    "  a _specification_ of a recipe step that will convert",
    "  a list-column of 3-column matrices of persistence data",
    "  to a list-column of 1-row matrices of vectorizations."
  )
  
  c(fn_title_doc, "", fn_descr, "") |> 
    doc_wrap() |> 
    as.list() |> c(list("\n\n")) |> 
    do.call(what = glue::glue)
}
# build_title_descr("computeNL")

# generate details
build_details <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_name <- tdavec_content |> 
    filter(name == fn) |> 
    pull(full_name) |> first() |> 
    tolower() |> capitalize_proper_names()
  fn_line <- c(
    paste0("The ", fn_name, " vectorization deploys"),
    paste0(link_obj(fn), "."),
    "See there for definitions and references."
  )
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_params <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname() |> 
    intersect(names(param_dials))
  fn_dials <- unname(param_dials[fn_params])
  fn_bullets <- param_bullets[fn_dials]
  fn_type <- dial_types[fn_dials]
  fn_defaults <- param_defaults[fn_dials]
  
  fn_tunables <- paste0(
    "This step has ", length(fn_dials),
    " tuning parameter", if (length(fn_dials) > 1L) "s", ":"
  )
  fn_tunings <- paste0(
    "  \\item `", fn_dials, "`: ", fn_bullets,
    " (type: ", fn_type, ", default: `", fn_defaults, "`)"
  )
  
  c(
    "",
    "@template step-vpd-details",
    "",
    "@section Engine:",
    "",
    fn_line,
    "",
    # "\\describe{{}}",
    # "",
    "@section Tuning Parameters:",
    "",
    fn_tunables,
    "\\itemize{{",
    fn_tunings,
    "}}",
    ""
  ) |> 
    doc_wrap() |> 
    as.list() |> c(list("\n")) |> 
    do.call(what = glue::glue)
}
# build_details("computePI")

# generate parameter documentation
build_param_docs <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_params <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname()
  fn_param_docs <- mapply(
    \(p, d) c(paste0("@param ", p, "\n", d[1L]), d[-1L]),
    p = gsub("([xy]{1})other", "\\1min,\\1max,\\1len,\\1by", fn_params),
    d = param_docs[fn_params]
  ) |> 
    unname() |> unlist() |> 
    strsplit("\n *") |> unlist() |> 
    gsub(pattern = "^([^@]+)", replacement = "  \\1") |> 
    doc_wrap() |> as.list() |> c(list("\n\n"))
  
  do.call(what = glue::glue, args = fn_param_docs)
}
# build_param_docs("computePL")

# generate importation and inheritance instructions
# (include argument for `do.call()` in source code generation)
build_import_inherit <- function(fn) {
  glue::glue(
    doc_wrap("@import recipes"),
    doc_wrap("@inheritParams recipes::step_pca"),
    doc_wrap("@inherit recipes::step_pca return"),
    "\n"
  )
}
# build_import_inherit()

# generate link to example file
build_ex <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_line <- 
    glue::glue("@example inst/examples/{build_prefix}-step-vpd-{fn_abbr}.R")
  
  glue::glue(doc_wrap(fn_line), "\n\n")
}
# build_ex("computePS")

#' Generate step functions.

# generate `step_*()`
build_step <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_set <- paste0(
    "    ", custom_params_set(fn_args), ",\n",
    collapse = ""
  )
  fn_pass <- paste0(
    "      ", custom_params_pass(fn_args), ",\n",
    collapse = ""
  )
  
  # TODO: Can't this be done using `paste0()`?
  glue::glue(
    doc_wrap("@export"),
    "step_vpd_{fn_abbr} <- function(\n",
    "    recipe,\n",
    "    ...,\n",
    # standard inputs
    "    role = \"predictor\",\n",
    "    trained = FALSE,\n",
    # custom parameters
    "{fn_set}",
    # standard parameters
    "    columns = NULL,\n",
    "    keep_original_cols = TRUE,\n",
    "    skip = FALSE,\n",
    "    id = rand_id(\"vpd_{fn_abbr}\")\n",
    ") {{\n",
    # ensure that required packages are installed
    "  recipes_pkg_check(required_pkgs.step_vpd_{fn_abbr}())\n",
    "  \n",
    # output the step addition
    "  add_step(\n",
    "    recipe,\n",
    "    step_vpd_{fn_abbr}_new(\n",
    "      terms = rlang::enquos(...),\n",
    "      trained = trained,\n",
    "      role = role,\n",
    "{fn_pass}",
    "      columns = columns,\n",
    "      keep_original_cols = keep_original_cols,\n",
    "      skip = skip,\n",
    "      id = id\n",
    "    )\n",
    "  )\n",
    "}}\n",
    "\n\n"
  )
}
# build_step("computeVPB")

# generate `step_*_new()`
build_step_new <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_leave <- paste0(
    "    ", custom_params_leave(fn_args), ",\n",
    collapse = ""
  )
  fn_pass <- paste0(
    "    ", custom_params_pass(fn_args), ",\n",
    collapse = ""
  )
  
  glue::glue(
    "step_vpd_{fn_abbr}_new <- function(\n",
    # standard inputs
    "    terms,\n",
    "    role, trained,\n",
    # custom parameters
    "{fn_leave}",
    # standard parameters
    "    columns, keep_original_cols,\n",
    "    skip, id\n",
    ") {{\n",
    # output the step
    "  step(\n",
    "    subclass = \"vpd_{fn_abbr}\",\n",
    "    terms = terms,\n",
    "    role = role,\n",
    "    trained = trained,\n",
    "{fn_pass}",
    "    columns = columns,\n",
    "    keep_original_cols = keep_original_cols,\n",
    "    skip = skip,\n",
    "    id = id\n",
    "  )\n",
    "}}\n",
    "\n\n"
  )
}
# build_step_new("computePES")

# generate `prep.step_vpd_*()`
build_prep <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_elt <- paste0(
    "    ", custom_params_elt(fn_args), ",\n",
    collapse = ""
  )
  fn_preproc <- param_preprocesses[arg_params[fn_args]] |> 
    lapply(\(v) c(v, "")) |> 
    unlist() |> unname() |> 
    (\(l) paste0("  ", l, "\n", collapse = ""))()
  
  glue::glue(
    doc_wrap("@export"),
    "prep.step_vpd_{fn_abbr} <- function(x, training, info = NULL, ...) {{\n",
    # extract columns and ensure they are lists of 3-column numeric tables
    "  col_names <- recipes_eval_select(x$terms, training, info)\n",
    # ensure that columns are list-columns of 3-column persistence diagrams
    "  check_phom_list(training[, col_names, drop = FALSE])\n",
    # TODO: Delete this conversion here if not needed below.
    # remove troublesome 'AsIs' class (and any other non-'list' classes)
    "  for (col_name in col_names) class(training[[col_name]]) <- \"list\"\n",
    "  \n",
    "{fn_preproc}",
    # output prepped step
    "  step_vpd_{fn_abbr}_new(\n",
    "    terms = col_names,\n",
    "    role = x$role,\n",
    "    trained = TRUE,\n",
    "{fn_elt}",
    "    columns = col_names,\n",
    "    keep_original_cols = get_keep_original_cols(x),\n",
    "    skip = x$skip,\n",
    "    id = x$id\n",
    "  )\n",
    "}}\n",
    "\n\n"
  )
}
# build_prep("computePL")

# generate `bake.step_vpd_*()`
build_bake <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_compute <- paste0(
    "        ", custom_params_compute(fn_args), "",
    collapse = ",\n"
  ) |> paste0("\n")
  
  glue::glue(
    doc_wrap("@export"),
    "bake.step_vpd_{fn_abbr} <- function(object, new_data, ...) {{\n",
    "  col_names <- names(object$columns)\n",
    "  check_new_data(col_names, object, new_data)\n",
    # remove troublesome 'AsIs' class (and any other non-'list' classes)
    "  for (col_name in col_names) class(new_data[[col_name]]) <- \"list\"\n",
    "  \n",
    # tabulate vectorizations of each persistence data column
    "  vph_data <- tibble::tibble(.rows = nrow(new_data))\n",
    # TODO: compare with existing recipes and decide to store vectorizations as
    # * matrices in list columns (with or without names)
    # * data frames in list columns (require names)
    # * numerous additional columns (require names)
    "  for (col_name in col_names) {{\n",
    "    col_vpd <- purrr::map(\n",
    "      new_data[[col_name]],\n",
    "      \\(d) TDAvec::{fn}(\n",
    "        as.matrix(d),\n",
    "{fn_compute}",
    "      )\n",
    "    )\n",
    # col_vpd <- lapply(col_vpd, matrix, nrow = 1L)\n",
    "    col_vpd <- purrr::map(\n",
    "      col_vpd,\n",
    "      \\(v) as.data.frame(matrix(\n",
    "        v, nrow = 1L, dimnames = list(NULL, seq(length(v)))\n",
    "      ))\n",
    "    )\n",
    "    vph_data[[paste(col_name, \"{fn_abbr}\", sep = \"_\")]] <- col_vpd\n",
    "  }}\n",
    # unnest data-framed matrices to ensure commensurate columns
    "  vph_data <- tidyr::unnest(\n",
    "    vph_data,\n",
    "    cols = tidyr::all_of(paste(col_names, \"{fn_abbr}\", sep = \"_\")),\n",
    "    names_sep = \"_\"\n",
    "  )\n",
    "  \n",
    "  check_name(vph_data, new_data, object)\n",
    "  new_data <- vctrs::vec_cbind(new_data, vph_data)\n",
    "  new_data <- remove_original_cols(new_data, object, col_names)\n",
    "  new_data\n",
    "}}\n",
    "\n\n"
  )
}
# build_bake("computeECC")

# generate `print.step_vpd_*()`
build_print <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_name <- tdavec_content |> 
    filter(name == fn) |> 
    pull(full_name) |> first() |> 
    snakecase::to_sentence_case() |> capitalize_proper_names()
  
  glue::glue(
    doc_wrap("@export"),
    "print.step_vpd_{fn_abbr} <- function(\n",
    "    x, width = max(20, options()$width - 35), ...\n",
    ") {{\n",
    "  title <- \"{fn_name} of \"\n",
    "  \n",
    "  print_step(\n",
    # names before prep (could be selectors)
    "    untr_obj = x$terms,\n",
    # names after prep
    "    tr_obj = NULL,\n",
    # whether recipe has been prepped
    "    trained = x$trained,\n",
    # what the recipe does
    "    title = title,\n",
    # estimated number of characters to print per line
    "    width = width\n",
    "  )\n",
    "  invisible(x)\n",
    "}}\n",
    "\n\n"
  )
}
# build_print("computePES")

# generate `required_pkgs.step_vpd_*()`
build_req <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  
  glue::glue(
    doc_wrap("@rdname required_pkgs.tdarec"),
    doc_wrap("@export"),
    "required_pkgs.step_vpd_{fn_abbr} <- function(x, ...) {{\n",
    "  c(\"TDAvec\", \"tdarec\")\n",
    "}}\n",
    "\n\n"
  )
}
# build_req("computePL")

# generate `tidy.step_vpd_*()`
build_tidy <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  
  glue::glue(
    doc_wrap("@rdname step_vpd_{fn_abbr}"),
    doc_wrap("@usage NULL"),
    doc_wrap("@export"),
    "tidy.step_vpd_{fn_abbr} <- function(x, ...) {{\n",
    "  if (is_trained(x)) {{\n",
    "    res <- tibble::tibble(\n",
    "      terms = unname(x$columns),\n",
    "      value = rep(NA_real_, length(x$columns))\n",
    "    )\n",
    "  }} else {{\n",
    "    term_names <- sel2char(x$terms)\n",
    "    res <- tibble::tibble(\n",
    "      terms = term_names,\n",
    "      value = rep(NA_real_, length(term_names))\n",
    "    )\n",
    "  }}\n",
    "  res$id <- x$id\n",
    "  res\n",
    "}}\n",
    "\n\n"
  )
}
# build_tidy("computeNL")

# generate `tunable.step_vpd_*()`
build_tunable <- function(fn) {
  fn_abbr <- abbr_vec(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_params <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname() |> 
    intersect(names(param_dials))
  fn_dials <- unname(param_dials[fn_params])
  fn_ranges <- dial_ranges[fn_dials] |> 
    sapply(paste0, collapse = ", ")
  fn_params_string <- paste0("\"", paste0(fn_params, collapse = "\", \""), "\"")
  fn_dials_string <- paste0(
    "      list(pkg = \"tdarec\", fun = \"",
    fn_dials,
    "\", range = c(",
    fn_ranges,
    "))",
    collapse = ",\n"
  )
  
  glue::glue(
    doc_wrap("@rdname tunable_tdavec"),
    doc_wrap("@export"),
    "tunable.step_vpd_{fn_abbr} <- function(x, ...) {{\n",
    "  tibble::tibble(\n",
    # argument name
    "    name = c({fn_params_string}),\n",
    # dial generators
    "    call_info = list(\n",
    "{fn_dials_string}\n",
    "    ),\n",
    # source of tuning value
    "    source = \"recipe\",\n",
    # sub-source of tuning value
    "    component = \"step_vpd_{fn_abbr}\",\n",
    # unique identifier
    "    component_id = x$id\n",
    "  )\n",
    "}}\n",
    "\n\n"
  )
}
# build_tunable("computePL")

#' WRITING

#' Write step source code.

for (fn in tdavec_functions$name) {
  fn_abbr <- abbr_vec(fn)
  
  # initialize file
  step_file <- here::here(glue::glue("R/{build_prefix}-step-vpd-{fn_abbr}.R"))
  cat(build_warning, file = step_file, append = FALSE)
  
  # populate with elements
  list(
    build_title_descr,
    build_details,
    build_param_docs,
    build_import_inherit,
    build_ex,
    build_step,
    build_step_new,
    build_prep,
    build_bake,
    build_print,
    build_req,
    build_tidy,
    build_tunable
  ) |> 
    lapply(do.call, args = list(fn = fn)) |> 
    lapply(cat, file = step_file, append = TRUE)
}

#' Write examples.

# example parameter passes
ex_param_vals <- c(
  hom_degree = 1L,
  max_hom_degree = 2L,
  xmax = "max_death",
  xby = .01,
  ymax = "max_persistence",
  yby = .01,
  num_levels = 3,
  dist_power = 2,
  img_sigma = 1,
  block_size = 1
)

# write example files from template (overwrites existing files)
for (fn in tdavec_functions$name) {
  fn_abbr <- abbr_vec(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_params <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname() |> 
    intersect(names(ex_param_vals))
  fn_param_vals <- 
    paste0(fn_params, " = ", ex_param_vals[fn_params], collapse = ", ")
  
  ex_file <- 
    here::here(glue::glue("inst/examples/{build_prefix}-step-vpd-{fn_abbr}.R"))
  # cat(build_warning, file = ex_file, append = FALSE)
  
  readLines("man/ex/step-vpd-ex-template.R") |> 
    gsub(pattern = "step_vpd_", replacement = paste0("step_vpd_", fn_abbr)) |> 
    gsub(pattern = "\\{param_vals\\}", replacement = fn_param_vals) |> 
    write(file = ex_file, append = FALSE)
}
